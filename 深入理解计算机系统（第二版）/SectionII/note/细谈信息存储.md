### 细谈信息存储

#### 一些基础

- 计算机中以二进制方式进行存储，以8个二进制数为一组，称之为一个字节（byte）
- 由于二进制自身直接书写起来太繁琐，与十进制的转换又不方便，所以十六进制表示成为了代替的好方法，因为十六进制与二进制之间可以直接转换——一个字节刚好可以写为两位十六进制数，表示起来更为清晰。
  - 二进制转十六进制：从右往左，四位一分，高位不足补零，四位二进制数为一位十六进制数
  - 十六进制转二进制：从高位到低位，一位十六进制数展开为四位二进制数即可，不足四位高位补零
- C语言中，以`Ox` 或 `OX` 开头的一般指十六进制
- 计算机内部一般默认以补码方式表示有符号数
- 字符刚开始仅有ASCII码表示的部分必要符号，后为了表示各个国家的文字，同意重新制定了 UTF-8 编码（此编码兼容ASCII）

#### 一些延拓

- **大端和小端**
  - 据说两词最初来源于《格列佛游记》中关于鸡蛋是由大端打开还是小端打开的争执，两词被引入计算机领域后一直沿用
  - **最低有效字节：**一个$w$位的整数，其位表示为[$x_{w-1} $, $x_{w-2} $, $x_{w-3} $, ..., $x_3 $, $x_2 $, $x_1 $, $x_0 $]，其中$w_{x-1}$为最高有效位， $w_0$是最低有效位，如果扩展为字节，那么最左边字节的就是**最高有效字节**，最右边的就是**最低有效字节**
  - **小端法：**最低有效字节在前面的表示方法
  - **大端法：**最高有效字节在前面的表示方法
  - **举例：**有十六进制值：`OX01234567` ，内存地址由低到高
    - 小端存储：67 45 23 01
    - 大端存储：01 23 45 67
- **C语言中的位级运算**
  - 基础运算：与（&）或（|）非（取反~），和异或（^）
  - 最常见运用：交换函数
- **C语言中逻辑运算** 
  - 基础：与（&&）或（||）非（!）
- **C语言中移位运算**
  - 左移（<<）：丢弃最高位，低位补零
  - 右移（>>）：丢弃低位，高位补0（**逻辑右移**）；高位补最高有效位的值（**算术右移**）
  - 一些注意事项：
    - **C语言采用何种右移：**官方并未明确规定，但是编译器大多采用**算术右移**
    - **移位高于本身字节数：**如 `int`类型值（4字节）移位40，C语言并未明确规定如何处理，Java中规定与所占`bit`数取模后再进行移动

#### 重点深入

- **如何判断自己的电脑是大端还是小端**，可以写代码进行测试，如下：

```c
#include<stdio.h>

typedef unsigned char* byte_pointer;
void show_bytes(byte_pointer start, size_t len) {
    size_t i;
    for(i = 0; i < len; i++)
        printf(" %.2x", start[i]);
    printf("\n");
}

void show_int(int x) {
    show_bytes((byte_pointer) &x, sizeof(int));
}

void test_show_bytes(int val) {
    int ival = val;
 	show_int(ival);
}

int main(){
    test_show_bytes(12345);
    return 0;
}
```

**也就是依次打印出变量在内存中每一个字节的值进行判断**，不过讲道理，一般常见的个人电脑都采用小端法存储，Android 和 iPhone 系统都是小端法存储的。

- **C语言中移位的处理**（注意事项2）：经过我自己测试（gcc编译），在移位过大之时，会给出提醒（Warning）：不要大于 bit 数，并采用和Java相同的处理方式——取余后再移位